---
title: "Brand Tracking Q1 2025 Data Analysis - SMB Tariffs,  Social Media, streaming, podcasts"
author: "Graham Albert"
toc: true
number-sections: true
toc-location: left
format:
  pdf:
    documentclass: report
    keep-tex: true
    toc: true
    toc-depth: 5
    number-sections: true
    colorlinks: true
    highlight-style: github
execute:
  echo: false
  warning: true
  fig-width: 10
  fig-height: 4.5
  fig-format: png
  fig-asp: 900
editor: visual
cache: true
---

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
#| include: false
# install_and_load_packages_from_file.R
install_and_load_packages_from_file <- function(file_path) {
  # Read the list of packages from the specified text file
  listOfPackages <- scan(file_path, character(), quote = "")
  
  # Install and load packages
  for (pkg in listOfPackages) {
    if (!pkg %in% installed.packages()) {
      install.packages(pkg, dependencies = TRUE)
    }
    tryCatch({
      library(pkg, character.only = TRUE)
      cat(paste("Loaded package: ", pkg, "\n"))
    }, error = function(e) {
      cat(paste("Error loading package: ", pkg, "\n"))
      cat(paste("Error message: ", conditionMessage(e), "\n"))
    })
  }
}

# Call the function with the file path
install_and_load_packages_from_file("~/git/Cross-Sell/Functions/required_packages.txt")
runScriptsInCurrentDirectory <- function(directory = "Functions", skipScripts = character(0)) {
  # Get the list of R script files in the specified directory
  scriptFiles <- list.files(directory, pattern = ".R$", full.names = TRUE)
  
  # Check if there are any script files
  if (length(scriptFiles) == 0) {
    cat(paste("No R script files found in the '", directory, "' directory.\n", sep = ""))
    return(NULL)
  }
  
  # Iterate through the script files and run each one
  for (scriptFile in scriptFiles) {
    # Check if the script should be skipped
    if (basename(scriptFile) %in% skipScripts) {
      cat("Skipping script:", scriptFile, "\n")
      next
    }
    
    cat("Running script:", scriptFile, "\n")
    
    # Use tryCatch to run the script with a 15-second timeout
    tryCatch({
      system.time({
        source(scriptFile, local = TRUE)
      })$elapsed
    }, error = function(e) {
      cat("Script", scriptFile, "was not run (timed out).\n")
    })
    
    cat("Script", scriptFile, "completed.\n")
  }
}


# Specify the scripts to skip (replace with your script filenames)
scriptsToSkip <- c("create_summary_table.R","runScriptsInCurrentDirectory.R")

# Call the function to run scripts in the current directory, skipping specified scripts
runScriptsInCurrentDirectory(directory = "Functions",skipScripts = scriptsToSkip)

library(tidyr)
library(dplyr)
library(reshape2)
# This processing pipeline combines three functions to transform and process data.
# 1. It starts by converting the data from wide to long format using the to_long function.
# 2. Then it replaces NAs in the resulting dataframe with a specified default value.
# 3. Next, it factors all columns in the dataframe using the factorize_column function.
# 4. Finally, it calculates counts and percentages by grouping the last two columns (variable and value)
#    using the calculate_count_and_percentage function.
# Function to transform data from wide to long format with multiple id.vars
to_long <- function(dataframe, id.vars, variable.name, value.name) {
  if (!is.character(id.vars)) {
    stop("id.vars must be a character vector.")
  }
  
  melted_data <- reshape2::melt(dataframe, id.vars = id.vars, variable.name = variable.name, value.name = value.name)
  
  return(melted_data)
}

# Function to factorize all columns in a dataframe
factorize_column <- function(dataframe, columns = NULL) {
  if (is.null(columns)) {
    columns <- names(dataframe)
  }
  
  for (col in columns) {
    if (is.factor(dataframe[[col]])) {
      next
    }
    
    dataframe[[col]] <- as.factor(dataframe[[col]])
  }
  
  return(data.frame(dataframe))
}

# Function to calculate counts and percentages by grouping columns
calculate_count_and_percentage <- function(dataframe, group_columns = NULL) {
  if (is.null(group_columns)) {
    group_columns <- names(dataframe)[c(length(dataframe) - 1, length(dataframe))]
  }
  
  result <- dataframe %>%
    group_by(!!!syms(group_columns)) %>%
    summarise(count = n()) %>%
    mutate(perc = count / sum(count))
    
  return(data.frame(result))
}

# Updated process_data_pipeline function without total_rows
process_data_pipeline_single_column<- function(dataframe, id.var = NULL, default_value = 0, group_column = NULL) {
  df_long_data <- to_long(dataframe, id.vars = id.var, variable.name = "variable", value.name = "value")
  df_long_data <- replace(df_long_data, is.na(df_long_data), default_value)
  df_long_data <- factorize_column(df_long_data)
  df_long_data <- data.frame(df_long_data)
  result <- calculate_count_and_percentage(df_long_data, group_columns = group_column)
  result <- result[result$value != default_value, ]
  return(result)
}
library(extrafont)
library(magick)
library(jtools)
library(ggplot2)
library(reshape2)
library(scales)

#The bar_plot_percent function creates a bar plot with percentages. It takes a dataframe,
#dataframe, and the names of the x-axis variable, x_var, the y-axis variable, y_var, and 
#the fill variable, fill_var. Additional optional arguments include plot_name, facet_var, main_title
#, x_axis_label, y_axis_label, and y_limits. The function saves the plot as a PNG file and returns the plot object.

# Function to create a bar plot with percentages
bar_plot_percent <- function(dataframe, x_var, y_var = "perc", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = reorder(!!as.name(x_var), desc(!!as.name(y_var))), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)), vjust = 1, size = 2, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
  print(p)
}



#The function bar_plot_percent_ordered creates a bar plot with percentages, where 
#the bars are ordered by the values of the y-variable. It takes a dataframe, dataframe, 
#and the names of the x-axis variable, x_var, the y-axis variable, y_var, and the fill variable, 
#fill_var. It also accepts additional optional arguments such as plot_name, facet_var, main_title, x_axis_label,
#y_axis_label, and y_limits. The function saves the plot as a PNG file and returns the plot object.


# Updated function to create a bar plot with percentages, bars ordered by y values

# Updated function to create a bar plot with percentages, bars ordered by y values
bar_plot_percent_ordered <- function(dataframe, x_var, y_var = "Percentage", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = reorder(stringr::str_wrap(!!as.name(x_var), 5), -!!as.name(y_var)), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)),   vjust = 1, size = 3, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 8, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 12, height = 4.5, dpi = 1800)
  return(p) 
  print(p)
}


library(ggplot2)
library(scales)

# Function definition
bar_plot_percent <- function(dataframe, x_var, y_var = "Percentage", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Convert x_var to factor with ordered levels
  dataframe[[x_var]] <- factor(dataframe[[x_var]], levels = unique(dataframe[[x_var]]))
  
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = !!as.name(x_var), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)), vjust = 1, size = 2, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 12, height = 4.5, dpi = 1800)
  return(p)
}

#This function takes x,y and fill variables and generates a bar plot using theme
# and color pallette for presentations at Acrisure.



#The create_bar_chart function generates a bar plot using themes and a color palette 
#for presentations at Acrisure, taking as inputs data (the dataframe), x_var (the x-axis variable), 
#fill_var (the variable for fill), and facet_var (optional variable for facets).
#The function also has parameters for plot_name (output plot filename), percentage
#(whether to display percentages or counts), and main_title (title for the plot)

create_bar_chart <- function(data, x_var, fill_var = x_var, facet_var = NULL, plot_name = "defaultplot.png", percentage = FALSE, main_title = NULL) {
  # Load required packages
  library(extrafont)
  library(magick)
  library(jtools)
  library(ggplot2)
  library(reshape2)
  library(scales)
  
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C", "#313131")
  
  # Define the common theme
  apatheme <- theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 4, family = 'sans'),
      legend.title = element_blank(),
      plot.title = element_text(hjust = 0.5),
      legend.position = "none",
      axis.text.x = element_text(angle = 55, vjust = 1, hjust = 1)
    )
  
  # Create a ggplot
  p <- ggplot(data, aes(x = !!as.name(x_var), fill = !!as.name(fill_var))) +
    geom_bar(stat = ifelse(percentage, "identity", "count")) +
    apatheme +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(data[[fill_var]]))) +
    labs(title = ifelse(!is.null(main_title), main_title, plot_name), y = ifelse(percentage, "Pct. Selected", "Count"), x = NULL)
  
  # Add facet_wrap if facet_var is not NULL
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Calculate and add percentage or count labels to y-axis based on the 'percentage' argument
  if (percentage) {
    p <- p + geom_text(stat = 'identity', aes(label = paste0(round(100 * count / sum(count)), "%")), vjust = 1, size = 3, colour = "white")
  } else {
    p <- p + geom_text(stat = 'count', aes(label = after_stat(count)), vjust = 1, size = 3, colour = "white") # Set label text color to white
  }
  
  # Display the plot
  print(p)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
}


# Updated function to create a bar plot with percentages and bars ordered by y values
create_bar_chart_ordered <- function(dataframe, x_var, y_var, fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Count", y_limits = c(0, 1)) {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = reorder(!!as.name(x_var), -!!as.name(y_var)), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = sprintf("%.2f", !!as.name(y_var))), vjust = 1, size = 2, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display numbers rounded to two decimals
  p <- p + scale_y_continuous()
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
}




#The bar_chart_count function generates a bar chart with counts, considering inputs such as dataframe (the dataframe),
#x_var (the x-axis variable), fill_var (the variable for fill), plot_name (output plot filename), main_title (title for the plot), 
#x_axis_label (label for the x-axis), and y_axis_label (label for the y-axis).

# Updated function to create a bar chart with counts
bar_chart_count <- function(dataframe, x_var, fill_var, facet_var = NULL, plot_name = "default_plot.png", main_title = NULL, x_axis_label = NULL, y_axis_label = "Count") {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = factor(!!as.name(x_var)), fill = factor(!!as.name(fill_var)))) +
    geom_bar() +
    scale_fill_manual(values = custom_palette) +
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
}




library(ggplot2)
bar_chart_count_with_error <- function(dataframe, x_var, y_var, fill_var, facet_var = NULL, plot_name = "default_plot.png", main_title = NULL, x_axis_label = NULL, y_axis_label = "Count") {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = factor(!!as.name(x_var)), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity") +
    geom_errorbar(
      aes(x = factor(!!as.name(x_var)), ymin = !!as.name(y_var) - sd, ymax = !!as.name(y_var) + sd),
      width = 0.2, colour = "black"
    ) +
    scale_fill_manual(values = custom_palette) +
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
}

library(tidyr)
library(dplyr)
library(reshape2)

# Function to transform data from wide to long format with multiple id.vars
#to_long takes a dataframe and transforms it from wide to long format using the reshape2 package. 
#It takes dataframe as input and outputs the transformed data melted_data.
to_long <- function(dataframe, id.vars, variable.name, value.name) {
  if (!is.character(id.vars)) {
    stop("id.vars must be a character vector.")
  }
  melted_data <- reshape2::melt(dataframe, id.vars = id.vars, variable.name = variable.name, value.name = value.name)
  return(melted_data)
}

# Function to factorize all columns in a dataframe

#factorize_column converts all columns in the dataframe into factors, ensuring
#that each column is a factor variable. It takes dataframe as input and outputs
#the dataframe with all columns converted to factors.
# Function to factorize columns while maintaining the order of the levels
# Function to factorize columns while maintaining the original levels order
factorize_column <- function(dataframe, columns = NULL, levels = NULL) {
  if (is.null(columns)) {
    columns <- names(dataframe)
  }
  for (col in columns) {
    if (is.factor(dataframe[[col]])) {
      next
    }
    if (is.null(levels)) {
      dataframe[[col]] <- as.factor(dataframe[[col]])
    } else {
      dataframe[[col]] <- factor(dataframe[[col]], levels = unique(dataframe[[col]]))
    }
  }
  return(dataframe)
}


# Function to calculate counts and percentages by grouping columns
# Updated calculate_count_and_percentage function to calculate counts and percentages within each level of group_columns

#calculate_count_and_percentage calculates counts and percentages by grouping columns 
#specified in group_columns. It groups the dataframe, calculates the count and percentage within each group, 
#and then ungroups the data. It takes dataframe as input and outputs the resulting calculated counts and percentages.

calculate_count_and_percentage <- function(dataframe, group_columns = NULL) {
  if (is.null(group_columns)) {
    group_columns <- names(dataframe)[c(length(dataframe) - 1, length(dataframe))]
  }
  
  result <- dataframe %>%
    group_by(!!!syms(group_columns)) %>%
    summarise(count = n()) %>%
    mutate(perc = count / sum(count)) %>%
    ungroup()  # Remove grouping
  
  return(result)
}

#new_percent calculates new percentages by multiplying the existing percentage (perc) 
#in the dataframe with the difference between total_columns and the length of id_vars. 
#It takes dataframe as input and outputs the dataframe with the new percentage added.

# Function to calculate new percentages
new_percent <- function(dataframe, id_vars, total_columns) {
  require(dplyr)
  difference <- total_columns - length(id_vars)
  dataframe <- dataframe %>%
    mutate(new_perc = perc * difference)
  return(dataframe)
}

# Updated process_data_pipeline function without total_rows argument
#process_data_pipeline_multiple_columns is an updated version of the data processing pipeline function. 
#It performs the following steps: transforming data from wide to long format, replacing NAs with a default value, 
#converting all columns to factors, ensuring the data is in a dataframe, calculating count and percentage, 
#removing rows where the value column equals 0, and finally calculating new percentages. 
#It takes dataframe as input and outputs the processed data.

process_data_pipeline_multiple_columns <- function(dataframe, id.var = NULL, default_value = 0, group_column = NULL) {
  # Step 1: Transform data from wide to long format using to_long
  df_long_data <- to_long(dataframe, id.vars = id.var, variable.name = "variable", value.name = "value")
  
  # Step 2: Replace NAs with default_value
  df_long_data <- replace(df_long_data, is.na(df_long_data), default_value)
  
  # Step 3: Factorize all columns
  df_long_data <- factorize_column(df_long_data)
  
  # Step 4: Ensure the data is in a data.frame
  df_long_data <- data.frame(df_long_data)
  
  # Step 5: Calculate count and percentage with the specified group_column
  result <- calculate_count_and_percentage(df_long_data, group_columns = group_column)
  
  # Step 6: Remove rows where value column equals 0
  result <- result[result$value != default_value, ]
  
  # Step 7: Calculate new percentages
  result <- new_percent(result, id_vars = id.var, total_columns = ncol(dataframe))
  
  return(result)
}

#| include: false
#The compute_mean_and_se function computes the mean and standard error for all columns
#except the first two (ID and Name) in a dataframe, taking dataframe as an input and an 
#optional column_names parameter for specific columns.

#The compute_mean_and_se_grouped function, which utilizes the dplyr package, computes 
#the mean and standard error grouped by a categorical variable, taking dataframe as an 
#input and optional parameters such as column_names for specific columns and groupby for the grouping variable. 
#This function also checks for numeric columns and skips non-numeric ones.


#Compute mean and SE for all columns except the first two (ID and Name)
compute_mean_and_se <- function(dataframe, column_names = NULL) {
  # If column_names is not specified, select all columns except the first two
  if (is.null(column_names)) {
    column_names <- names(dataframe)[3:length(dataframe)]
  }
  
  # Initialize an empty dataframe to store the results
  result_df <- data.frame(Column = character(0), Mean = numeric(0), SE = numeric(0))
  
  # Loop through the specified column names
  for (col_name in column_names) {
    # Check if the column is a factor
    if (is.factor(dataframe[[col_name]])) {
      # Convert factor to numeric
      dataframe[[col_name]] <- as.numeric(dataframe[[col_name]])
    }
    
    # Subset the dataframe to exclude NA values in the current column
    subset_df <- dataframe[!is.na(dataframe[[col_name]]), ]
    
    # Compute the mean and standard error
    mean_val <- mean(subset_df[[col_name]])
    se_val <- sd(subset_df[[col_name]]) / sqrt(length(subset_df[[col_name]]))
    
    # Create a new row for the result dataframe
    result_row <- data.frame(Column = col_name, Mean = mean_val, SE = se_val)
    
    # Append the result row to the result dataframe
    result_df <- rbind(result_df, result_row)
  }
  
  return(result_df)
}


#Compute mean and se grouped by a categorical variab;le
library(dplyr)

compute_mean_and_se_grouped <- function(dataframe, column_names = NULL, groupby = NULL) {
  # If column_names is not specified, select all columns except the first two
  if (is.null(column_names)) {
    column_names <- names(dataframe)[3:length(dataframe)]
  }
  
  # Initialize an empty dataframe to store the results
  result_df <- data.frame(Column = character(0), Group = character(0), Mean = numeric(0), SE = numeric(0))
  
  # Loop through the specified column names
  for (col_name in column_names) {
    # Check if the column is numeric
    if (is.numeric(dataframe[[col_name]])) {
      # If groupby is specified, calculate mean and SE within each group using dplyr
      if (!is.null(groupby)) {
        grouped_data <- dataframe %>%
          group_by_at(vars(all_of(groupby))) %>%
          summarise(Mean = mean(.data[[col_name]], na.rm = TRUE),
                    SE = sd(.data[[col_name]], na.rm = TRUE) / sqrt(n())) %>%
          mutate(Column = col_name)
        
        result_df <- bind_rows(result_df, grouped_data)
      } else {
        # Subset the dataframe to exclude NA values in the current column
        subset_df <- dataframe[!is.na(dataframe[[col_name]]), ]
        
        # Compute the mean and standard error
        mean_val <- mean(subset_df[[col_name]])
        se_val <- sd(subset_df[[col_name]]) / sqrt(length(subset_df[[col_name]]))
        
        # Create a new row for the result dataframe
        result_row <- data.frame(Column = col_name, Group = "Overall", Mean = mean_val, SE = se_val)
        
        # Append the result row to the result dataframe
        result_df <- bind_rows(result_df, result_row)
      }
    } else {
      cat("Column", col_name, "is not numeric. Skipping...\n")
    }
  }
  
  return(result_df)
}

library(wordcloud)
library(tm)
library(RColorBrewer)

# List of common stop words in English
stop_words <- c("i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours", "yourself", "yourselves",
                "he", "him", "his", "himself", "she", "her", "hers", "herself", "it", "its", "itself", "they", "them", "their",
                "theirs", "themselves", "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are", "was",
                "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "a", "an", "the", "and",
                "but", "if", "or", "because", "as", "until", "while", "of", "at", "by", "for", "with", "about", "against", "between",
                "into", "through", "during", "before", "after", "above", "below", "to", "from", "up", "down", "in", "out", "on", "off",
                "over", "under", "again", "further", "then", "once", "here", "there", "when", "where", "why", "how", "all", "any",
                "both", "each", "few", "more", "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so",
                "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now", "d", "ll", "m", "o", "re", "ve", "y",
                "ain", "aren", "couldn", "didn", "doesn", "hadn", "hasn", "haven", "isn", "ma", "mightn", "mustn", "needn", "shan",
                "shouldn", "wasn", "weren", "won", "wouldn")

generate_wordcloud <- function(dataframe, text_column, output_filename) {
  # Parameter validation
  if (!text_column %in% colnames(dataframe)) {
    stop("The specified text column does not exist in the dataframe.")
  }
  if (nrow(dataframe) == 0) {
    stop("The dataframe is empty.")
  }
  
  tryCatch({
    # Create a Corpus from the text_column
    corpus <- Corpus(VectorSource(dataframe[[text_column]]))
    
    # Convert to lowercase and remove punctuation
    corpus <- tm_map(corpus, content_transformer(tolower))
    corpus <- tm_map(corpus, removePunctuation)
    
    # Remove common stop words
    corpus <- tm_map(corpus, removeWords, stop_words)
    
    # Create a Document-Term Matrix
    dtm <- DocumentTermMatrix(corpus)
    
    # Convert the Document-Term Matrix to a matrix
    word_freq_matrix <- as.matrix(dtm)
    
    # Calculate word frequencies
    word_freqs <- colSums(word_freq_matrix)
    
    # Create a data frame of word frequencies
    word_freq_df <- data.frame(word = names(word_freqs), freq = word_freqs)
    
    # Filter out words that are two letters or shorter
    word_freq_df <- word_freq_df[nchar(as.character(word_freq_df$word)) > 2, ]
    
    # Set up the word cloud plot dimensions
    par(mar = rep(1, 4))  # Adjust the margins as needed
    
    # Create a word cloud with the specified color palette and white background
    wordcloud(
      words = word_freq_df$word,
      freq = word_freq_df$freq,
      scale = c(3, 0.5),
      min.freq = 1,
      colors = c("#002A4E", "#36749D", "#85714D", "#000000", "#004F51", "#95174C", "#313131"),  # Specified color palette
      bg = "white"
    )
    
    # Save the word cloud as a PNG file
    png(filename = paste0(output_filename, ".png"), width = 800, height = 600, res = 100) # Adjust width, height, and res as needed
    print(wordcloud(words = word_freq_df$word, freq = word_freq_df$freq, scale = c(3, 0.5), min.freq = 1, 
                    colors = c("#002A4E", "#36749D", "#85714D", "#000000", "#004F51", "#95174C", "#313131"), bg = "white"))
    dev.off() # Close the PNG device
  }, error = function(e) {
    cat("An error occurred: ", conditionMessage(e), "\n")
  })
}


library(ggplot2)
library(dplyr)
library(ggplot2)
library(dplyr)

# Create a sample custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C", "#FAF9F6")

# Function to plot the frequency of the top 10 phrases
plot_top_phrases <- function(dataframe, column_name, plot_name = "top_phrases_plot.png") {
  # Group and count the phrases in the specified column
  phrase_counts <- dataframe %>%
    group_by(!!sym(column_name)) %>%
    summarize(Count = n()) %>%
    arrange(desc(Count)) %>%
    slice_head(n = 10)
  
  # Determine the number of unique phrases
  num_unique_phrases <- nrow(phrase_counts)
  
  # Create a fill column to assign unique colors from the custom palette
  phrase_counts$Fill <- rep(custom_palette, length.out = num_unique_phrases)
  
  # Create a ggplot bar chart
  p <- ggplot(phrase_counts, aes(x = reorder(!!sym(column_name), -Count), y = Count, fill = Fill)) +
    geom_bar(stat = "identity") +
    labs(title = paste("Top 10 Phrases in", column_name), y = "Frequency") +
    scale_fill_identity() +  # Use the assigned colors
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 300)
  
  # Display the plot
  print(p)
}
library(ggplot2)
library(dplyr)

# Create a sample custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C", "#FAF9F6")

# Function to plot the frequency of the top 10 phrases
plot_top_phrases <- function(dataframe, column_name, plot_name = "top_phrases_plot.png") {
  # Group and count the phrases in the specified column
  phrase_counts <- dataframe %>%
    group_by(!!sym(column_name)) %>%
    summarize(Count = n()) %>%
    arrange(desc(Count)) %>%
    slice_head(n = 10)
  
  # Determine the number of unique phrases
  num_unique_phrases <- nrow(phrase_counts)
  
  # Create a fill column to assign unique colors from the custom palette
  phrase_counts$Fill <- rep(custom_palette, length.out = num_unique_phrases)
  
  # Create a ggplot bar chart
  p <- ggplot(phrase_counts, aes(x = reorder(!!sym(column_name), -Count), y = Count, fill = Fill)) +
    geom_bar(stat = "identity") +
    labs(title = paste("Top 10 Phrases in", column_name), y = "Frequency") +
    scale_fill_identity() +  # Use the assigned colors
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 300)
  
  # Display the plot
  print(p)
}



# Explanation of the Custom Horizontal Bar Plot Function:
# This function takes a dataframe and several customizable parameters to create a horizontal bar plot using ggplot2.
# Users can specify the x-axis variable, y-axis variable, fill variable, plot name, facet variable for faceted plots,
# main title, x-axis label, y-axis label, and y-axis limits.
# Load required libraries
library(tidyverse)
library(scales)

# Custom color palette
library(ggplot2)

# Function to create a customizable horizontal bar plot
create_horizontal_bar_plot <- function(
    dataframe,
    x_var,
    y_var = "perc",
    fill_var,
    plot_name = "default_plot.png",
    main_title = NULL,
    x_axis_label = NULL,
    y_axis_label = "Pct Selected",
    y_limits = c(0, 1)
) {
  p <- ggplot(dataframe, aes(x = {{x_var}}, y = {{y_var}}, fill = {{fill_var}})) +
    geom_col() +
    geom_text(aes(label = scales::percent({{y_var}})),
              position = position_stack(vjust = 0.5),
              color = "white",
              size = 2.5) +
    coord_flip() +
    scale_x_discrete() +
    scale_fill_manual(values = custom_palette) +
    labs(
      title = ifelse(is.null(main_title), "", main_title),
      x = ifelse(is.null(x_axis_label), "", x_axis_label),
      y = ifelse(is.null(y_axis_label), "", y_axis_label)
    ) +
    theme_minimal() +
    ylim(y_limits)
  
  ggsave(plot_name, plot = p, width = 10, height = 6, dpi = 300)
  return(p)
}

# Example usage:
set.seed(123)
test_df <- data.frame(
  Category = rep(c("A", "B", "C"), each = 3),
  Value = runif(9),
  Group = rep(c("Group1", "Group2", "Group3"), times = 3)
)

custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")

create_horizontal_bar_plot(
  dataframe = test_df,
  x_var = Category,
  y_var = Value,
  fill_var = Group,
  plot_name = "custom_plot.png",
  main_title = "Custom Plot",
  x_axis_label = "X-Axis Label",
  y_axis_label = "Custom Y-Axis Label",
  y_limits = c(0, 1)
)


library(tidyverse)
library(scales)
library(reshape2)


# Main pipeline function
custom_pipeline <- function(
    dataframe,
    variable_columns,
    Rating
) {
  dataframe %>%
    pivot_longer(cols = all_of(variable_columns), names_to = "Variable", values_to = "Value") %>%
    group_by(Variable, Value) %>%
    summarise(Count = n()) %>%
    ungroup() %>%
    mutate(
      Proportion = if_else(
        Value %in% Rating,
        Count / sum(Count),
        NA_real_
      ),
      Percentage = scales::percent(Proportion, accuracy = 1)
    ) %>%
    arrange(Variable)
}

# Example usage of the custom_pipeline function
set.seed(123)
test_df <- data.frame(
  response_id = 1:100,
  q1 = sample(c("A", "B", "C", "D"), 100, replace = TRUE),
  q2 = sample(c("X", "Y", "Z"), 100, replace = TRUE),
  q3 = sample(c("Yes", "No"), 100, replace = TRUE)
)

custom_result <- custom_pipeline(
  dataframe = test_df,
  variable_columns = c("q1", "q2", "q3"),
  Rating = c("A", "X", "Yes")
)

print(custom_result)


library(extrafont)
library(magick)
library(jtools)
library(ggplot2)
library(reshape2)
library(scales)

#The bar_plot_percent function creates a bar plot with percentages. It takes a dataframe,
#dataframe, and the names of the x-axis variable, x_var, the y-axis variable, y_var, and 
#the fill variable, fill_var. Additional optional arguments include plot_name, facet_var, main_title
#, x_axis_label, y_axis_label, and y_limits. The function saves the plot as a PNG file and returns the plot object.

# Function to create a bar plot with percentages
bar_plot_percent <- function(dataframe, x_var, y_var = "perc", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = reorder(stringr::str_wrap(!!as.name(x_var), 15), desc(!!as.name(y_var))), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)),   vjust = 1, size = 3, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 8, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 0, vjust = 1, hjust=0.5)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
  print(p)
}



#The function bar_plot_percent_ordered creates a bar plot with percentages, where 
#the bars are ordered by the values of the y-variable. It takes a dataframe, dataframe, 
#and the names of the x-axis variable, x_var, the y-axis variable, y_var, and the fill variable, 
#fill_var. It also accepts additional optional arguments such as plot_name, facet_var, main_title, x_axis_label,
#y_axis_label, and y_limits. The function saves the plot as a PNG file and returns the plot object.


# Updated function to create a bar plot with percentages, bars ordered by y values
bar_plot_percent_ordered <- function(dataframe, x_var, y_var = "Percentage", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(x = reorder(stringr::str_wrap(!!as.name(x_var), 15), -!!as.name(y_var)), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)),   vjust = 1, size = 3, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 8, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p) 
  print(p)
}

# Example usage:
data_df <- data.frame(
  Category = rep(c("A", "B", "C", "D"), each = 4),
  Percentage = runif(16, min = 0, max = 100)
  
)

bar_plot_percent(
  dataframe = data_df,
  x_var = "Category",        # Use quotes for variable names
  y_var = "Percentage",      # Use quotes for variable names
  fill_var = "Category",  # Use quotes for variable names
  plot_name = "bar_plot_percentage.png",
  main_title = "Bar Plot Example",
  x_axis_label = "Categories",
  y_axis_label = "Percentage"
)


library(ggplot2)
library(scales)

# Sample dataframe for testing
data_df <- data.frame(
  Category = as.factor(c(1, 2, 3, 4, 5, 4, 1, 3, 2, 5)),
  Percentage = runif(10, min = 0, max = 100),
  Group = rep(c("A", "B"), each = 5)
)

# Function definition
bar_plot_percent <- function(dataframe, x_var, y_var = "Percentage", fill_var, plot_name = "default_plot.png", facet_var = NULL, main_title = NULL, x_axis_label = NULL, y_axis_label = "Pct Selected", y_limits = c(0, 1)) {
  # Convert x_var to factor with ordered levels
  dataframe[[x_var]] <- factor(dataframe[[x_var]], levels = unique(dataframe[[x_var]]))
  
  # Define the color palette
  custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
  
  # Create a ggplot
  p <- ggplot(dataframe, aes(stringr::str_wrap(!!as.name(x_var), 15), y = !!as.name(y_var), fill = factor(!!as.name(fill_var)))) +
    geom_bar(stat = "identity", width = 0.4) +
    geom_text(stat = 'identity', aes(label = round(!!as.name(y_var) * 100)),   vjust = 1, size = 0, colour = "white") +
    scale_fill_manual(values = rep(custom_palette, length.out = n_distinct(dataframe[[fill_var]]))) +
    expand_limits(y = y_limits) +  # Adjust y-axis limits
    labs(title = main_title, y = y_axis_label, x = x_axis_label) +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 8, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 0, vjust = 1, hjust=0.5)
    )
  
  # Apply facet_wrap if facet_var is specified
  if (!is.null(facet_var)) {
    p <- p + facet_wrap(vars(!!as.name(facet_var)))
  }
  
  # Scale y-axis to display percentages
  p <- p + scale_y_continuous(labels = scales::percent)
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 1800)
  return(p)
}

# Test the function
bar_plot_percent(data_df, "Category", "Percentage", "Group", "bar_plot_ordered.png", main_title = "Bar Plot Example", x_axis_label = "Categories", y_axis_label = "Percentage")



##############################################################################
#1 load_survey_data() takes the necessary parameters (API key, base URL, survey 
#ID, and output filename) and calls the other helper functions.
#2	load_libraries(): This function loads the required R packages:qualtRics, sjlabelled, tidyverse, janitor, and skimr.
#3	set_api_credentials(): This function sets the Qualtrics API credentials using the provided API key and base URL.
#4	fetch_survey_data(): This function fetches the survey data from Qualtrics using the provided survey ID.
#5	save_survey_responses(): This function saves the survey data as a CSV file with the given filename.
#6	read_csv_and_get_colnames(): This function reads the CSV file, gets the column names, and returns the column names and the raw data.
#7	main(): This is the main function that orchestrates the entire process. It calls the helper functions in the correct order to load the survey data, save it as a CSV file, and print the column names.
##############################################################################

load_survey_data <- function(api_key = NULL, base_url = NULL, surveyID) {
  # Load necessary libraries
  load_libraries <- function() {
    library(qualtRics)
    library(sjlabelled)
    library(tidyverse)
    library(janitor)
    library(skimr)
    library(magrittr)
  }
  
  # Set API credentials
  set_api_credentials <- function(api_key, base_url) {
    qualtrics_api_credentials(api_key = api_key,
                              base_url = base_url,
                              overwrite = TRUE,
                              install = TRUE)
  }
  
  # Fetch survey data
  fetch_survey_data <- function(surveyID) {
    tryCatch(
      {
        fetch_survey(surveyID = surveyID, force_request = TRUE)
      },
      error = function(e) {
        message("Error fetching survey data: ", e$message)
        message("Please check your API key and base URL.")
        stop("Qualtrics API authentication error")
      }
    )
  }
  
  # Save survey responses as a CSV file
  save_survey_responses <- function(data, filename) {
    write.csv(data, file = filename, row.names = FALSE)
  }
  
  # Read CSV file and get column names
  read_csv_and_get_colnames <- function(filename, skip_rows = 3) {
    col_names <- colnames(readr::read_csv(filename, n_max = 0))
    raw_data <- readr::read_csv(filename, col_names = col_names, skip = skip_rows)
    list(col_names = col_names, raw_data = raw_data)
  }
  
  # Define columns to remove
  cols_to_remove <- c(
    "StartDate", "EndDate", "Status", "IPAddress", "Progress", "Duration (in seconds)",
    "Finished", "RecordedDate", "RecipientLastName", "RecipientFirstName", "RecipientEmail",
    "ExternalReference", "LocationLatitude", "LocationLongitude", "DistributionChannel",
    "UserLanguage", "Q_RecaptchaScore", "Q_RelevantIDDuplicate", "Q_RelevantIDDuplicateScore",
    "Q_RelevantIDFraudScore", "Q_RelevantIDLastStartDate", "SC0", "opp", "Q_TotalDuration",
    "RISN", "rid", "LS", "V", "CMRID", "Q_CHL", "Q_BallotBoxStuffing", "Redix", "tg", "wave",
    "transaction_id", "SVID", "PS", "ResponseID", "PID", "psid", "K2", "med", "orderNumber",
    "gc", "term", "pureSpectrumRedirectUrl", "pureSpectrumSignatureValue"
  )
  
  # Load API key and base URL from .Renviron file
  readRenviron("~/.Renviron")
  
  # Set API credentials
  if (is.null(api_key) || is.null(base_url)) {
    api_key <- Sys.getenv("QUALTRICS_API_KEY")
    base_url <- Sys.getenv("QUALTRICS_BASE_URL")
  }
  set_api_credentials(api_key, base_url)
  
  # Fetch survey data
  survey_data <- fetch_survey_data(surveyID)
  
  # Save survey responses as a CSV file
  save_survey_responses(survey_data, "datafile.csv")
  
  # Check overlap with actual column names in data file
  load_libraries()
  csv_info <- read_csv_and_get_colnames("datafile.csv")
  col_names <- csv_info$col_names
  cols_to_remove_id <- col_names %in% cols_to_remove
  cols_to_remove <- col_names[cols_to_remove_id]
  
  # Remove the unwanted Qualtrics columns
  raw_data <- csv_info$raw_data
  raw_data <- dplyr::select(raw_data, !all_of(cols_to_remove))
  
  # Initial cleaning: Convert column names to tidyverse style guide and remove empty rows and columns
  cleaned_data <- janitor::clean_names(raw_data)
  dplyr::glimpse(cleaned_data)
  
  # Define function to delete columns with substring and retain
  delete_columns_with_substring_and_retain <- function(df, substring_to_delete, substring_to_retain) {
    deleted_columns <- vector("character", length = 0)
    for (col in names(df)) {
      if (grepl(substring_to_delete, col) && !grepl(substring_to_retain, col)) {
        df <- df[, !(names(df) %in% col)]
        deleted_columns <- c(deleted_columns, col)
      }
    }
    cat("Deleted columns:", paste(deleted_columns, collapse = ", "), "\n")
    return(df)
  }
  
  # Delete columns with substring 'DO' and retain columns with 'DO_DO'
  cleaned_data <- delete_columns_with_substring_and_retain(cleaned_data, '_do_', '_do_do_')
  
  # Delete columns with substring 'ADO' and retain columns with 'ADO_ADO'
  cleaned_data <- delete_columns_with_substring_and_retain(cleaned_data, '_ado_', '_ado_ado_')
  
  return(cleaned_data)
}





```

#### Load new and updated functions

```{r}
#| include: false
library(ggplot2)
library(dplyr)
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C", "#FAF9F6")
#' Generate Horizontal Bar Chart
#'
#' This function generates a horizontal bar chart from a given dataframe. It allows the user to specify the variable names, variable labels, value labels, and a custom color palette.
#'
#' @param df The input dataframe.
#' @param file_name The name of the output file to be saved.
#' @param question_names A vector of column names to be used for the chart.
#' @param var_labels A vector of variable labels to be used for the x-axis.
#' @param value_labels A vector of value labels to be used for the legend.
#' @param custom_palette A vector of custom colors to be used for the bars.
#'
#' @return The generated horizontal bar chart plot object.

generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette, bar_order) {
  
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Variable column to match the desired order
  reduced_df_long$Variable <- factor(reduced_df_long$Variable, levels = bar_order)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = rev(value_labels))
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 2, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = rev(custom_palette[1:length(value_labels)])) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  # Return the plot object and the reduced_df_long_perc dataframe
  return(list(plot = plot, data = reduced_df_long_perc))
}

# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output3.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 2", "Variable 4", "Variable 1", "Variable 6", "Variable 3", "Variable 5", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette,
  bar_order = c("q66_shared_2", "q66_shared_4", "q66_shared_1", "q66_shared_6", "q66_shared_3", "q66_shared_5", "q66_shared_7")
)


# create_regression_plot function takes a dataframe and creates a regression plot
# with options to display data points. It plots the relationship between the
# variables specified by x_var and y_var with a linear regression line.
# Additional customization options include setting the main_title, y_axis_label,
# x_axis_label, line_color, and whether to display data points using geom_point.
# The inputs for this function are dataframe (the input dataframe), x_var and y_var (the variables to be plotted).

# The function create_regression_plot generates a regression plot, and the example
# provided demonstrates how to use the function with sample data.

# Note this graph creates a regression plot
create_regression_plot <- function(dataframe, x_var, y_var, main_title = NULL, y_axis_label = NULL, x_axis_label = NULL, line_color = "#002A4E", plot_name = NULL) {
  # Check for missing values
  if (any(sapply(dataframe, function(x) any(is.na(x))))) {
    stop("The input dataframe contains missing values. Please handle them before using this function.")
  }
  
  # Check if the input arguments are valid
  stopifnot(
    x_var %in% names(dataframe),
    y_var %in% names(dataframe)
  )
  
  # Create a base plot with a linear regression line
  plot <- ggplot(dataframe, aes(x = !!rlang::sym(x_var), y = !!rlang::sym(y_var))) +
    geom_smooth(method = "lm", se = TRUE, color = line_color) +
    geom_point(size = 2, color = "#36749D") +
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      plot.title = element_text(hjust = 0.5), # Center the title
      plot.margin = margin(20, 20, 20, 20) # Add margin to the plot
    ) +
    labs(
      title = ifelse(!is.null(main_title), main_title, NULL),
      x = ifelse(!is.null(x_axis_label), x_axis_label, x_var),
      y = ifelse(!is.null(y_axis_label), y_axis_label, y_var)
    )
  
  # Save the plot as a PNG file if plot_name is provided
  if (!is.null(plot_name)) {
    ggsave(filename = plot_name, plot = plot, width = 10, height = 4.5, dpi = 1800)
  }
  
  return(plot)
}

# Example usage for a regression plot with points
set.seed(123)
data_df <- data.frame(
  X = rnorm(100),
  Y = rnorm(100)
)

plot_object <- create_regression_plot(
  data_df, x_var = "X", y_var = "Y",
  main_title = "Regression Plot",
  y_axis_label = "Y-Axis Label",
  x_axis_label = "X-Axis Label",
  line_color = "#002A4E",
  plot_name = "regression_plot.png"
)
print(plot_object)



library(ggplot2)
library(dplyr)

# Create a sample custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C", "#FAF9F6")

# Function to plot the frequency of the top 10 phrases
plot_top_phrases <- function(dataframe, column_name, plot_name = "top_phrases_plot.png") {
  # Check if the input dataframe and column_name are valid
  if (!is.data.frame(dataframe) || !is.character(column_name) || !column_name %in% names(dataframe)) {
    stop("Invalid input dataframe or column_name.")
  }
  
  # Group and count the phrases in the specified column
  phrase_counts <- dataframe %>%
    group_by(!!sym(column_name)) %>%
    summarize(Count = n()) %>%
    arrange(desc(Count)) %>%
    slice_head(n = 10)
  
  # Determine the number of unique phrases
  num_unique_phrases <- nrow(phrase_counts)
  
  # Create a fill column to assign unique colors from the custom palette
  phrase_counts$Fill <- rep(custom_palette, length.out = num_unique_phrases)
  
  # Create a ggplot bar chart
  p <- ggplot(phrase_counts, aes(x = reorder(!!sym(column_name), -Count), y = Count, fill = Fill)) +
    geom_bar(stat = "identity") +
    labs(title = paste("Top 10 Phrases in", column_name), y = "Frequency") +
    scale_fill_identity() + # Use the assigned colors
    theme_bw() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.line = element_line(),
      text = element_text(size = 6, family = 'sans'),
      legend.title = element_blank(),
      legend.position = "none",
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)
    )
  
  # Save the plot as a PNG file
  ggsave(filename = plot_name, plot = p, width = 10, height = 4.5, dpi = 300)
  
  # Display the plot
  print(p)
}

generate_multiple_phrase_barcharts <- function(dataframe) {
  for (column_name in names(dataframe)) {
    if (is.character(dataframe[[column_name]])) {
      plot_name <- paste0(column_name, "_phrases_barchart.png")
      plot_top_phrases(dataframe, column_name, plot_name)
    } else {
      message("Column '", column_name, "' is not a text column. Skipping this column.")
    }
  }
}

# Create a sample dataframe
sample_data <- data.frame(
  ID = 1:10,
  question1 = c("apple", "banana", "apple", "cherry", "banana", "apple", "banana", "cherry", "date", "apple"),
  question2 = c("orange", "pear", "orange", "kiwi", "pear", "orange", "pear", "kiwi", "mango", "orange"),
  numeric_column = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
)

# Generate multiple phrase barcharts
generate_multiple_phrase_barcharts(sample_data)




#The generate_wordcloud function takes a dataframe, a text column, and an output filename as inputs. 
#It creates a word cloud plot from the text data in the specified column using the wordcloud function
#from the wordcloud package. It calculates the word frequencies, 
#sets up the plot dimensions, and saves the resulting word cloud as a PNG file with a fixed dark blue color and white background

# Example of how to call the function to save the word cloud plot


library(wordcloud)
library(tm)
library(RColorBrewer)

# List of common stop words in English
stop_words <- c("i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours", "yourself", "yourselves",
                "he", "him", "his", "himself", "she", "her", "hers", "herself", "it", "its", "itself", "they", "them", "their",
                "theirs", "themselves", "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are", "was",
                "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "a", "an", "the", "and",
                "but", "if", "or", "because", "as", "until", "while", "of", "at", "by", "for", "with", "about", "against", "between",
                "into", "through", "during", "before", "after", "above", "below", "to", "from", "up", "down", "in", "out", "on", "off",
                "over", "under", "again", "further", "then", "once", "here", "there", "when", "where", "why", "how", "all", "any",
                "both", "each", "few", "more", "most", "other", "some", "such", "no", "nor", "not", "only", "own", "same", "so",
                "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now", "d", "ll", "m", "o", "re", "ve", "y",
                "ain", "aren", "couldn", "didn", "doesn", "hadn", "hasn", "haven", "isn", "ma", "mightn", "mustn", "needn", "shan",
                "shouldn", "wasn", "weren", "won", "wouldn")

generate_wordcloud <- function(dataframe, text_column, output_filename, color_palette = c("#002A4E", "#36749D", "#85714D", "#000000", "#004F51", "#95174C", "#313131")) {
  # Parameter validation
  if (is.null(dataframe) || is.null(text_column) || is.null(output_filename)) {
    stop("All parameters must be provided.")
  }
  
  if (!text_column %in% colnames(dataframe)) {
    stop("The specified text column does not exist in the dataframe.")
  }
  
  if (nrow(dataframe) == 0) {
    message("The dataframe is empty. No word cloud can be generated.")
    return(invisible())
  }
  
  tryCatch({
    # Create a Corpus from the text_column
    corpus <- Corpus(VectorSource(dataframe[[text_column]]))
    
    # Convert to lowercase and remove punctuation
    corpus <- tm_map(corpus, content_transformer(tolower))
    corpus <- tm_map(corpus, removePunctuation)
    
    # Remove common stop words
    corpus <- tm_map(corpus, removeWords, stop_words)
    
    # Create a Document-Term Matrix
    dtm <- DocumentTermMatrix(corpus)
    
    # Convert the Document-Term Matrix to a matrix
    word_freq_matrix <- as.matrix(dtm)
    
    # Calculate word frequencies
    word_freqs <- colSums(word_freq_matrix)
    
    # Create a data frame of word frequencies
    word_freq_df <- data.frame(word = names(word_freqs), freq = word_freqs)
    
    # Filter out words that are two letters or shorter
    word_freq_df <- word_freq_df[nchar(as.character(word_freq_df$word)) > 2, ]
    
    # Set up the word cloud plot dimensions
    par(mar = rep(1, 4)) # Adjust the margins as needed
    
    # Create a word cloud with the specified color palette and white background
    word_cloud <- wordcloud(
      words = word_freq_df$word,
      freq = word_freq_df$freq,
      scale = c(3, 0.5),
      min.freq = 1,
      colors = color_palette,
      bg = "white"
    )
    
    # Save the word cloud as a PNG file
    png(filename = paste0(output_filename, ".png"), width = 800, height = 600, res = 100) # Adjust width, height, and res as needed
    print(word_cloud)
    dev.off() # Close the PNG device
    
    return(word_cloud)
  }, error = function(e) {
    cat("An error occurred: ", conditionMessage(e), "\n")
  })
}

set.seed(123)
sample_data <- data.frame(
  text_column = c(
    "This is a sample text for the word cloud.",
    "Another example text to be included.",
    "Testing the word cloud function.",
    "Final text sample for the word cloud."
  )
)


generate_wordcloud(sample_data, "text_column", "sample_wordcloud")

word_cloud_object <- generate_wordcloud(sample_data, "text_column", "sample_wordcloud")

custom_palette <- c("#002A4E", "#36749D", "#85714D", "#000000", "#004F51", "#95174C", "#313131")
word_cloud_object <- generate_wordcloud(sample_data, "text_column", "sample_wordcloud", color_palette = custom_palette)






##Newest version 20240516

#' Generate Horizontal Bar Chart
#'
#' This function generates a horizontal bar chart from a given dataframe. It allows the user to specify the variable names, variable labels, value labels, and a custom color palette.
#'
#' @param df The input dataframe.
#' @param file_name The name of the output file to be saved.
#' @param question_names A vector of column names to be used for the chart.
#' @param var_labels A vector of variable labels to be used for the x-axis.
#' @param value_labels A vector of value labels to be used for the legend.
#' @param custom_palette A vector of custom colors to be used for the bars.
#'
#' @return The generated horizontal bar chart plot object.

generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette, bar_order) {
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Variable column to match the desired order
  reduced_df_long$Variable <- factor(reduced_df_long$Variable, levels = bar_order)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = value_labels)
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 2, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = custom_palette[1:length(value_labels)], 
                      breaks = rev(levels(reduced_df_long_perc$Value))) +  # Reverse the order of labels in the legend
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  # Return the plot object and the reduced_df_long_perc dataframe
  return(list(plot = plot, data = reduced_df_long_perc))
}

# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output3.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 2", "Variable 4", "Variable 1", "Variable 6", "Variable 3", "Variable 5", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette,
  bar_order = c("q66_shared_2", "q66_shared_4", "q66_shared_1", "q66_shared_6", "q66_shared_3", "q66_shared_5", "q66_shared_7")
)


#' Generate Horizontal Bar Chart
#'
#' This function generates a horizontal bar chart from a given dataframe. It allows the user to specify the variable names, value labels, and a custom color palette.
#'
#'@param df The input dataframe.
#'@param file_name The name of the output file to be saved.
#'@param question_names A vector of column names to be used for the chart.
#'@param var_labels A vector of variable labels to be used for the x-axis.
#'@param value_labels A vector of value labels to be used for the legend.
#'@param custom_palette A vector of custom colors to be used for the bars.
#'
#'@return The function saves the generated chart as a PNG file.

generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette) {
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.6) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete() +
    scale_fill_manual(values = setNames(custom_palette[1:length(value_labels)], value_labels)) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          text = element_text(size = 12, family = 'sans'),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
}

# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

# Test the function
custom_palette <- c("#002A4E", "#36749D","#85714D", "#004F51", "#000000",  "#95174C","#DDE9F0")

generate_horizontal_bar_chart(
  sample_df,
  "sample_output.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette
)






library(ggplot2)
library(dplyr)

#' Generate Horizontal Bar Chart
#'
#' This function generates a horizontal bar chart from a given dataframe. It allows the user to specify the variable names, variable labels, value labels, and a custom color palette.
#'
#' @param df The input dataframe.
#' @param file_name The name of the output file to be saved.
#' @param question_names A vector of column names to be used for the chart.
#' @param var_labels A vector of variable labels to be used for the x-axis.
#' @param value_labels A vector of value labels to be used for the legend.
#' @param custom_palette A vector of custom colors to be used for the bars.
#'
#' @return The generated horizontal bar chart plot object.


generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette) {
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = rev(value_labels))
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = rev(custom_palette[1:length(value_labels)])) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          text = element_text(size = 12, family = 'sans'),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  # Return the plot object
  return(plot)
}


# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

# Test the function
custom_palette <- c("#002A4E", "#36749D", "#85714D","#004F51", "#000000",  "#95174C","#DDE9F0")

plot_object <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3","q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 1", "Variable 2", "Variable 3", "Variable 4", "Variable 5", "Variable 6", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette
)






generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette) {
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = rev(value_labels))
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = rev(custom_palette[1:length(value_labels)])) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          text = element_text(size = 12, family = 'sans'),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  # Return the plot object and the reduced_df_long_perc dataframe
  return(list(plot = plot, data = reduced_df_long_perc))
}

# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

# Test the function
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")
result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output2.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 1", "Variable 2", "Variable 3", "Variable 4", "Variable 5", "Variable 6", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette
)

# Access the plot object and the data frame
plot_object <- result$plot
reduced_df_long_perc <- result$data




generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette, bar_order) {
  
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Variable column to match the desired order
  reduced_df_long$Variable <- factor(reduced_df_long$Variable, levels = bar_order)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = rev(value_labels))
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = rev(custom_palette[1:length(value_labels)])) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          text = element_text(size = 12, family = 'sans'),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  # Return the plot object and the reduced_df_long_perc dataframe
  return(list(plot = plot, data = reduced_df_long_perc))
}


result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output3.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 2", "Variable 4", "Variable 1", "Variable 6", "Variable 3", "Variable 5", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette,
  bar_order = c("q66_shared_2", "q66_shared_4", "q66_shared_1", "q66_shared_6", "q66_shared_3", "q66_shared_5", "q66_shared_7")
)



generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette, bar_order) {
  reduced_df <- dplyr::select(df, response_id, all_of(question_names))
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Variable column to match the desired order using forcats::fct_relevel()
  reduced_df_long$Variable <- forcats::fct_relevel(reduced_df_long$Variable, bar_order)
  
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = rev(value_labels))
  
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = rev(custom_palette[1:length(value_labels)])) +
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(
      axis.text.x = element_blank(),
      axis.title.x = element_blank(),
      panel.grid = element_blank(),
      text = element_text(size = 12, family = 'sans'),
      legend.position = "top"
    )
  
  ggsave(file_name, plot, height = 4.5, width = 10, dpi = 1800)
  
  return(list(plot = plot, data = reduced_df_long_perc))
}


result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output3.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 2", "Variable 4", "Variable 1", "Variable 6", "Variable 3", "Variable 5", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette,
  bar_order = c("q66_shared_2", "q66_shared_4", "q66_shared_1", "q66_shared_6", "q66_shared_3", "q66_shared_5", "q66_shared_7")
)


##Newest version 20240516

#' Generate Horizontal Bar Chart
#'
#' This function generates a horizontal bar chart from a given dataframe. It allows the user to specify the variable names, variable labels, value labels, and a custom color palette.
#'
#' @param df The input dataframe.
#' @param file_name The name of the output file to be saved.
#' @param question_names A vector of column names to be used for the chart.
#' @param var_labels A vector of variable labels to be used for the x-axis.
#' @param value_labels A vector of value labels to be used for the legend.
#' @param custom_palette A vector of custom colors to be used for the bars.
#'
#' @return The generated horizontal bar chart plot object.

generate_horizontal_bar_chart <- function(df, file_name, question_names, var_labels, value_labels, custom_palette, bar_order) {
  # Select relevant columns
  reduced_df <- dplyr::select(df, response_id, !!!syms(question_names))
  
  # Reshape the data to long format
  reduced_df_long <- tidyr::pivot_longer(reduced_df, cols = -response_id, names_to = "Variable", values_to = "Value")
  
  # Remove NAs
  reduced_df_long <- na.omit(reduced_df_long)
  
  # Reorder the Variable column to match the desired order
  reduced_df_long$Variable <- factor(reduced_df_long$Variable, levels = bar_order)
  
  # Reorder the Value column to match the desired order
  reduced_df_long$Value <- factor(reduced_df_long$Value, levels = value_labels)
  
  # Calculate the percentage of respondents for each value
  reduced_df_long_perc <- reduced_df_long %>%
    group_by(Variable, Value) %>%
    summarize(Count = n()) %>%
    mutate(Proportion = Count / sum(Count),
           Percentage = scales::percent(Proportion, accuracy = 1)) %>%
    ungroup()
  
  # Create the horizontal bar chart
  plot <- ggplot(reduced_df_long_perc, aes(x = Variable, y = Proportion, fill = Value)) +
    geom_col(position = "fill", width = 0.9) +
    geom_text(aes(label = Percentage), position = position_fill(vjust = 0.5), size = 4, color = "white") +
    coord_flip() +
    scale_x_discrete(labels = var_labels) +
    scale_fill_manual(values = custom_palette[1:length(value_labels)], 
                      breaks = rev(levels(reduced_df_long_perc$Value))) +  # Reverse the order of labels in the legend
    labs(title = "", x = NULL, fill = NULL) +
    theme_minimal() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank(),
          panel.grid = element_blank(),
          text = element_text(size = 12, family = 'sans'),
          legend.position = "top")
  
  # Save the plot as a PNG file
  ggsave(file_name, plot, height = 4.5, width = 12, dpi = 1800)
  
  # Return the plot object and the reduced_df_long_perc dataframe
  return(list(plot = plot, data = reduced_df_long_perc))
}

# Sample dataframe
set.seed(123)
sample_df <- data.frame(
  response_id = 1:100,
  q66_shared_1 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_2 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_3 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_4 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_5 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_6 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE),
  q66_shared_7 = sample(c("Yes", "No", "Maybe", "Unsure"), 100, replace = TRUE)
)

result <- generate_horizontal_bar_chart(
  sample_df,
  "sample_output3.png",
  question_names = c("q66_shared_1", "q66_shared_2", "q66_shared_3", "q66_shared_4", "q66_shared_5", "q66_shared_6", "q66_shared_7"),
  var_labels = c("Variable 2", "Variable 4", "Variable 1", "Variable 6", "Variable 3", "Variable 5", "Variable 7"),
  value_labels = c("Yes", "No", "Maybe", "Unsure"),
  custom_palette = custom_palette,
  bar_order = c("q66_shared_2", "q66_shared_4", "q66_shared_1", "q66_shared_6", "q66_shared_3", "q66_shared_5", "q66_shared_7")
)
```

# Brand Tracking Q3 2024

## **Summary**

The QSS team launched a brand-tracking survey in Q1.

Acrisure brand awareness has room for growth and remains consistent with previous quarters. Critically, brand sentiment toward Acrisure remains positive.

## Methods

### Study Purpose

The primary purpose of this study was to continue to track brand awareness of Acrisure and its competitors. This will inform the decisions of the Innovation team and AGM. Secondary purposes of this study included:

1.  Tracking respondents future purchase consideration of insurance products, employee benefits (commercial lines only), and financial services products.

2.  Tracking respondents awareness of and sentiment towards Acrisure and other insurance providers.

3.  Tracking respondents awareness of and sentiment towards Acrisures new brand ambassdor, Lionel Richie, along with their awareness of and sentiment towards other insurance brand ambassadors.

....

### **Recruitment**

Participants were recruited via Qualtrics. Data collection occurred between...

### **Questions**

The survey was programmed in Qualtrics. For the Commercial Lines survey there were a total of X questions and the median completion time was 15 minutes. The IR for the personal lines sample was X.

For the Personal Lines survey there were a total of X questions and the median completion time was 15 minutes. The IR for the personal lines sample was X%.

### **New Questions**

## **Sample**

The sample was a stratified sample. We collected a PL Sample and a CL Sample. A total of 616 PL and X CL respondents completed the survey. The IR for the CL sample was X%. The IR for PL sample was XX%?

### **Screening**

For both samples all individuals were required to be US adults. For the Personal Lines sample individuals must represent Acrisures target customers, that is they must either have owned a home or a car and hold a home or auto policy, or both. For the Commercial Lines sample individuals were required to either be small business owners, equity partners in a business or individuals who are involved in insurance and/or employee benefit decision making.

### Load Data Files

```{r}
BTQ2 <- read.csv("/Users/grahamalbert/git/Brand-Tracking-Q2-2025/BTQ2_DF_MERGED_DF_INCREASED.csv")
BTQ2
```

```{r}
BTQ2$RESPONDENT_TYPE<-factor(BTQ2$RESPONDENT_TYPE,
  levels = c(1,2),
  labels = c("PL","CL")
)
BTQ2
```

```{r}
# Define the breaks for age categories
breaks <- c(18, 30, 40, 50, 60, 70, 80)

# Create age categories using cut()
BTQ2$age_categories <- cut(BTQ2$q3_shared, breaks = breaks, labels = c("18-30", "30-40", "40-50", "50-60", "60-70", "70+"), include.lowest = TRUE, right = FALSE)
```

### Commercial Lines

```{r}
BTQ2_CL<-subset(BTQ2,RESPONDENT_TYPE=="CL")
colnames(BTQ2_CL)

# Define the breaks for the bins
breaks <- seq(0, 500, by = 20)

# Define the labels for the bins
labels <- c('0-20', '21-40', '41-60', '61-80', '81-100', '101-120', '121-140', '141-160', '161-180', '181-200', 
            '201-220', '221-240', '241-260', '261-280', '281-300', '301-320', '321-340', '341-360', '361-380', 
            '381-400', '401-420', '421-440', '441-460', '461-480', '481-500')

# Convert the numeric variable to a categorical variable
BTQ2_CL$company_size <- cut(BTQ2_CL$q25_cl, breaks = breaks, labels = labels, include.lowest = TRUE)

# Print the result
BTQ2_CL$company_size
```

### Personal Lines

```{r}
BTQ2_PL<-subset(BTQ2,RESPONDENT_TYPE=="PL")
colnames(BTQ2_PL)
```

## Media Consumptions

### Streaming

```{r}
#| label: fig-Streaming-channel-usage
#| fig-cap: Streaming preference of respondents,
#| warning: false
STREAMING_DF<-dplyr::select(BTQ2,response_id,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)
STREAMING_DF_PERC <- process_data_pipeline_multiple_columns(STREAMING_DF, id.var = c("response_id"), default_value = 0, group_column = c("value"))
STREAMING_DF_PERC
bar_plot_percent_ordered(STREAMING_DF_PERC, "value", "new_perc", "value", "STREAMING_DF_PERC.png", main_title = "", x_axis_label = " ", y_axis_label = "Pct. Selected",y_limits = 0.5)
```

```{r}
STREAMING_DF_REDUCED<-dplyr::select(BTQ2,response_id,q4_shared,q11_shared,age_categories,q75_shared_1,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)

STREAMING_DF_REDUCED_analytic_data_survey_factorized <- lapply(STREAMING_DF_REDUCED, function(x) as.factor(as.character(x)))
STREAMING_DF_REDUCED_analytic_data_survey_factorized<-data.frame(STREAMING_DF_REDUCED_analytic_data_survey_factorized) 
summary(STREAMING_DF_REDUCED_analytic_data_survey_factorized)


STREAMING_DF_REDUCED_REPLACED <- replace_NA_with_value(STREAMING_DF_REDUCED_analytic_data_survey_factorized, columns = c("q75_shared_1","q61_shared_1","q61_shared_2","q61_shared_3","q61_shared_4","q61_shared_5","q61_shared_6","q61_shared_7","q61_shared_8","q61_shared_9","q61_shared_10","q61_shared_11","q61_shared_12"), replace_value = 999)
STREAMING_DF_REDUCED_REPLACED

# Print the result dataframe
print(STREAMING_DF_REDUCED_REPLACED)

```

Generate the tables of interest

Streaming by HHI

```{r}
require(vtable)
STREAMING_BY_HHI<-st(STREAMING_DF_REDUCED_REPLACED,vars = c("q61_shared_1","q61_shared_2","q61_shared_3","q61_shared_4","q61_shared_5","q61_shared_6","q61_shared_7","q61_shared_8","q61_shared_9","q61_shared_10","q61_shared_11","q61_shared_12"),group="q4_shared",out="csv",file="STREAMING_BY_HHI.csv")
STREAMING_BY_HHI
```

Streaming by HHI Plot

```{r}
require(dplyr)
STREAMING_HHI_DF<-dplyr::select(STREAMING_DF_REDUCED,response_id,q4_shared,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)

STREAMING_HHI_DF_LONG_PERC <- process_data_pipeline_multiple_columns(STREAMING_HHI_DF, id.var = c("response_id","q4_shared"), default_value = 0, group_column = c("q4_shared","value"))
STREAMING_HHI_DF_LONG_PERC$new_perc<-STREAMING_HHI_DF_LONG_PERC$new_perc*100
STREAMING_HHI_DF_LONG_PERC


STREAMING_HHI_DF_LONG_PERC<-STREAMING_HHI_DF_LONG_PERC%>%
                    mutate(q4_shared=factor(q4_shared, 
                             levels = c('$24,999 or less',
                                        '$25,000 - $49,999',
                                        '$50,000 - $74,999',
                                        '$75,000 – $99,999',
                                        '$100,000 - $149,999',
                                        '$150,000 - $199,999',
                                        '$200,000 - $249,999',
                                        '$250,000 or more',
                                        'Prefer not to say'
                                        ),ordered = TRUE))


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(STREAMING_HHI_DF_LONG_PERC, aes(x = factor(STREAMING_HHI_DF_LONG_PERC$q4_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "streaming-hhi.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Streaming by Gender

```{r}
require(vtable)

STREAMING_BY_GENDER<-st(STREAMING_DF_REDUCED_REPLACED,vars = c("q61_shared_1","q61_shared_2","q61_shared_3","q61_shared_4","q61_shared_5","q61_shared_6","q61_shared_7","q61_shared_8","q61_shared_9","q61_shared_10","q61_shared_11","q61_shared_12"),group="q11_shared",out="csv",file="STREAMING_BY_GENDER.csv")
STREAMING_BY_GENDER
```

Streaming by Gender Plot

```{r}
require(dplyr)
STREAMING_GENDER_DF<-dplyr::select(STREAMING_DF_REDUCED,response_id,q11_shared,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)

STREAMING_GENDER_DF_LONG_PERC <- process_data_pipeline_multiple_columns(STREAMING_GENDER_DF, id.var = c("response_id","q11_shared"), default_value = 0, group_column = c("q11_shared","value"))
STREAMING_GENDER_DF_LONG_PERC$new_perc<-STREAMING_GENDER_DF_LONG_PERC$new_perc*100
STREAMING_GENDER_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(STREAMING_GENDER_DF_LONG_PERC, aes(x = factor(STREAMING_GENDER_DF_LONG_PERC$q11_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "streaming-gender.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Streaming by Age Caterogries

```{r}
require(vtable)
STREAMING_BY_AGE_CAT<-st(STREAMING_DF_REDUCED_REPLACED,vars = c("q61_shared_1","q61_shared_2","q61_shared_3","q61_shared_4","q61_shared_5","q61_shared_6","q61_shared_7","q61_shared_8","q61_shared_9","q61_shared_10","q61_shared_11","q61_shared_12"),group="age_categories",out="csv",file="STREAMING_BY_AGE_CAT.csv")
STREAMING_BY_AGE_CAT
```

Streaming by Age Categories Plot

```{r}
require(dplyr)
STREAMING_AGE_CATEGORIES_DF<-dplyr::select(STREAMING_DF_REDUCED,response_id,age_categories,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)

STREAMING_AGE_CATEGORIES_DF_LONG_PERC <- process_data_pipeline_multiple_columns(STREAMING_AGE_CATEGORIES_DF, id.var = c("response_id","age_categories"), default_value = 0, group_column = c("age_categories","value"))
STREAMING_AGE_CATEGORIES_DF_LONG_PERC$new_perc<-STREAMING_AGE_CATEGORIES_DF_LONG_PERC$new_perc*100
STREAMING_AGE_CATEGORIES_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(STREAMING_AGE_CATEGORIES_DF_LONG_PERC, aes(x = factor(STREAMING_AGE_CATEGORIES_DF_LONG_PERC$age_categories), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "streaming-age-categories.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Streaming by Awareness of Acrisure

```{r}
require(vtable)
STREAMING_BY_AWARENESS_ACRISURE<-st(STREAMING_DF_REDUCED_REPLACED,vars = c("q61_shared_1","q61_shared_2","q61_shared_3","q61_shared_4","q61_shared_5","q61_shared_6","q61_shared_7","q61_shared_8","q61_shared_9","q61_shared_10","q61_shared_11","q61_shared_12"),group="q75_shared_1",out="csv",file="STREAMING_BY_AWARENESS_ACRISURE.csv")
STREAMING_BY_AWARENESS_ACRISURE
```

Streaming by Awareness of Acrisure

```{r}
require(dplyr)
STREAMING_AWARENESS_ACRISURE_DF<-dplyr::select(STREAMING_DF_REDUCED,response_id,q75_shared_1,q61_shared_1,q61_shared_2,q61_shared_3,q61_shared_4,q61_shared_5,q61_shared_6,q61_shared_7,q61_shared_8,q61_shared_9,q61_shared_10,q61_shared_11,q61_shared_12)

STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC <- process_data_pipeline_multiple_columns(STREAMING_AWARENESS_ACRISURE_DF, id.var = c("response_id","q75_shared_1"), default_value = 0, group_column = c("q75_shared_1","value"))
STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC$new_perc<-STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC$new_perc*100
STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC, aes(x = factor(STREAMING_AWARENESS_ACRISURE_DF_LONG_PERC$q75_shared_1), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "streaming-awareness-acrisure.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

### Social Media

```{r}
#| label: fig-Streaming-channel-usage
#| fig-cap: Streaming preference of respondents,
#| warning: false
SOCIAL_MEDIA_DF<-dplyr::select(BTQ2,response_id,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)
SOCIAL_MEDIA_DF_PERC <- process_data_pipeline_multiple_columns(SOCIAL_MEDIA_DF, id.var = c("response_id"), default_value = 0, group_column = c("value"))
STREAMING_DF_PERC
bar_plot_percent_ordered(SOCIAL_MEDIA_DF_PERC, "value", "new_perc", "value", "SOCIAL_MEDIA_DF_PERC.png", main_title = "", x_axis_label = " ", y_axis_label = "Pct. Selected",y_limits = 0.5)
```

Create the needed set

```{r}
SOCIAL_MEDIA_DF_REDUCED<-dplyr::select(BTQ2,response_id,q4_shared,q11_shared,age_categories,q75_shared_1,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)

SOCIAL_MEDIA_DF_REDUCED_analytic_data_survey_factorized <- lapply(SOCIAL_MEDIA_DF_REDUCED, function(x) as.factor(as.character(x)))
SOCIAL_MEDIA_DF_REDUCED_analytic_data_survey_factorized<-data.frame(SOCIAL_MEDIA_DF_REDUCED_analytic_data_survey_factorized) 
summary(SOCIAL_MEDIA_DF_REDUCED_analytic_data_survey_factorized)


SOCIAL_MEDIA_DF_REDUCED_REPLACED <- replace_NA_with_value(SOCIAL_MEDIA_DF_REDUCED_analytic_data_survey_factorized, columns = c("q75_shared_1","q62_shared_1","q62_shared_2","q62_shared_3","q62_shared_4","q62_shared_5","q62_shared_6","q62_shared_7","q62_shared_8","q62_shared_9","q62_shared_10"), replace_value = 999)
SOCIAL_MEDIA_DF_REDUCED_REPLACED

# Print the result dataframe
print(SOCIAL_MEDIA_DF_REDUCED_REPLACED)

```

Social media by HHI

```{r}
require(vtable)
SOCIAL_MEDIA_BY_HHI<-st(SOCIAL_MEDIA_DF_REDUCED_REPLACED,vars = c("q62_shared_1","q62_shared_2","q62_shared_3","q62_shared_4","q62_shared_5","q62_shared_6","q62_shared_7","q62_shared_8","q62_shared_9","q62_shared_10"),group="q4_shared",out="csv",file="SOCIAL_MEDIA_BY_HHI.csv")
SOCIAL_MEDIA_BY_HHI
```

Social media by HHI

```{r}
require(dplyr)
SOCIAL_MEDIA_BY_HHI_DF<-dplyr::select(SOCIAL_MEDIA_DF_REDUCED_REPLACED,response_id,q4_shared,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)

SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC <- process_data_pipeline_multiple_columns(SOCIAL_MEDIA_BY_HHI_DF, id.var = c("response_id","q4_shared"), default_value = 0, group_column = c("q4_shared","value"))
SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC$new_perc<-SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC$new_perc*100
SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC, aes(x = factor(SOCIAL_MEDIA_BY_HHI_DF_LONG_PERC$q4_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "social-media-HHI.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Social media by Gender

```{r}
require(vtable)

SOCIAL_MEDIA_BY_GENDER<-st(SOCIAL_MEDIA_DF_REDUCED_REPLACED,vars = c("q62_shared_1","q62_shared_2","q62_shared_3","q62_shared_4","q62_shared_5","q62_shared_6","q62_shared_7","q62_shared_8","q62_shared_9","q62_shared_10"),group="q11_shared",out="csv",file="SOCIAL_MEDIA_BY_GENDER.csv")
SOCIAL_MEDIA_BY_GENDER
```

Social media by Gender

```{r}
require(dplyr)
SOCIAL_MEDIA_BY_GENDER_DF<-dplyr::select(SOCIAL_MEDIA_DF_REDUCED_REPLACED,response_id,q11_shared,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)

SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC <- process_data_pipeline_multiple_columns(SOCIAL_MEDIA_BY_GENDER_DF, id.var = c("response_id","q11_shared"), default_value = 0, group_column = c("q11_shared","value"))
SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC$new_perc<-SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC$new_perc*100
SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC, aes(x = factor(SOCIAL_MEDIA_BY_GENDER_DF_LONG_PERC$q11_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "social-media-gender.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Social by Age Caterogries

```{r}
require(vtable)
SOCIAL_MEDIA_BY_AGE_CAT<-st(SOCIAL_MEDIA_DF_REDUCED_REPLACED,vars = c("q62_shared_1","q62_shared_2","q62_shared_3","q62_shared_4","q62_shared_5","q62_shared_6","q62_shared_7","q62_shared_8","q62_shared_9","q62_shared_10"),group="age_categories",out="csv",file="STREAMING_BY_AGE_CAT.csv")
SOCIAL_MEDIA_BY_AGE_CAT
```

Social media by Age Caterogries

```{r}
require(dplyr)
SOCIAL_MEDIA_BY_AGE_CAT_DF<-dplyr::select(SOCIAL_MEDIA_DF_REDUCED,response_id,age_categories,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)

SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC <- process_data_pipeline_multiple_columns(SOCIAL_MEDIA_BY_AGE_CAT_DF, id.var = c("response_id","age_categories"), default_value = 0, group_column = c("age_categories","value"))
SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC$new_perc<-SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC$new_perc*100
SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC, aes(x = factor(SOCIAL_MEDIA_BY_AGE_CAT_DF_LONG_PERC$age_categories), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "social-media-age-categories.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Social media by Awareness of Acrisure

```{r}
require(vtable)
SOCIAL_MEDIA_BY_AWARENESS_ACRISURE<-st(SOCIAL_MEDIA_DF_REDUCED_REPLACED,vars = c("q62_shared_1","q62_shared_2","q62_shared_3","q62_shared_4","q62_shared_5","q62_shared_6","q62_shared_7","q62_shared_8","q62_shared_9","q62_shared_10"),group="q75_shared_1",out="csv",file="SOCIAL_MEDIA_BY_AWARENESS_ACRISURE.csv")
SOCIAL_MEDIA_BY_AWARENESS_ACRISURE
```

Social media by Awareness of Acrisure

```{r}
require(dplyr)
SOCIAL_MEDIA_AWARENESS_ACRISURE_DF<-dplyr::select(SOCIAL_MEDIA_DF_REDUCED,response_id,q75_shared_1,q62_shared_1,q62_shared_2,q62_shared_3,q62_shared_4,q62_shared_5,q62_shared_6,q62_shared_7,q62_shared_8,q62_shared_9,q62_shared_10)

SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC <- process_data_pipeline_multiple_columns(SOCIAL_MEDIA_AWARENESS_ACRISURE_DF, id.var = c("response_id","q75_shared_1"), default_value = 0, group_column = c("q75_shared_1","value"))
SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC$new_perc<-SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC$new_perc*100
SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0",
                    "#002A4E", "#36749D",  "#85714D", "#000000", "#004F51", "#95174C","#DDE9F0")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC, aes(x = factor(SOCIAL_MEDIA_AWARENESS_ACRISURE_DF_LONG_PERC$q75_shared_1), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "social-media-awareness-acrisure.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

### Podcasts

```{r}
#| label: fig-Podcasts-channel-preference
#| fig-cap: Podcasts primarily usage
#| warning: false
PODCASTS_DF<-dplyr::select(BTQ2,response_id,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)
PODCASTS_DF_PERC <- process_data_pipeline_multiple_columns(PODCASTS_DF, id.var = c("response_id"), default_value = 0, group_column = c("value"))
bar_plot_percent_ordered(PODCASTS_DF_PERC, "value", "new_perc", "value", "PODCASTS_DF_PERC.png", main_title = "", x_axis_label = " ", y_axis_label = "Pct. Selected",y_limits = 0.5)
```

Create the needed set

```{r}
PODCASTS_DF_REDUCED<-dplyr::select(BTQ2,response_id,q4_shared,q11_shared,age_categories,q75_shared_1,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)

PODCASTS_DF_REDUCED_analytic_data_survey_factorized <- lapply(PODCASTS_DF_REDUCED, function(x) as.factor(as.character(x)))
PODCASTS_DF_REDUCED_analytic_data_survey_factorized<-data.frame(PODCASTS_DF_REDUCED_analytic_data_survey_factorized) 
summary(PODCASTS_DF_REDUCED_analytic_data_survey_factorized)


PODCASTS_DF_REDUCED_REPLACED <- replace_NA_with_value(PODCASTS_DF_REDUCED_analytic_data_survey_factorized, columns = c("q75_shared_1"), replace_value = 999)
PODCASTS_DF_REDUCED_REPLACED

# Print the result dataframe
print(PODCASTS_DF_REDUCED_REPLACED)

```

Podcasts by HHI

```{r}
require(vtable)
PODCAST_BY_HHI<-st(PODCASTS_DF_REDUCED_REPLACED,vars = c("q310_shared_1","q310_shared_2","q310_shared_3","q310_shared_4","q310_shared_5","q310_shared_6","q310_shared_7","q310_shared_8","q310_shared_9"),group="q4_shared",out="csv",file="PODCAST_BY_HHI.csv")
PODCAST_BY_HHI
```

Podcasts by Gender Plot

```{r}
require(dplyr)
PODCAST_BY_HHI_DF<-dplyr::select(PODCASTS_DF_REDUCED_REPLACED,response_id,q4_shared,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)

PODCAST_BY_HHI_DF_LONG_PERC <- process_data_pipeline_multiple_columns(PODCAST_BY_HHI_DF, id.var = c("response_id","q4_shared"), default_value = 0, group_column = c("q4_shared","value"))
PODCAST_BY_HHI_DF_LONG_PERC$new_perc<-PODCAST_BY_HHI_DF_LONG_PERC$new_perc*100
PODCAST_BY_HHI_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(PODCAST_BY_HHI_DF_LONG_PERC, aes(x = factor(PODCAST_BY_HHI_DF_LONG_PERC$q4_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "podcasts-HHI.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Podcasts by Gender

```{r}
require(vtable)
PODCAST_BY_GENDER<-st(PODCASTS_DF_REDUCED_REPLACED,vars = c("q310_shared_1","q310_shared_2","q310_shared_3","q310_shared_4","q310_shared_5","q310_shared_6","q310_shared_7","q310_shared_8","q310_shared_9"),group="q11_shared",out="csv",file="PODCAST_BY_GENDER.csv")
PODCAST_BY_GENDER
```

Podcasts by Gender Plot

```{r}
require(dplyr)
PODCAST_BY_GENDER_DF<-dplyr::select(PODCASTS_DF_REDUCED_REPLACED,response_id,q11_shared,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)

PODCAST_BY_GENDER_DF_LONG_PERC <- process_data_pipeline_multiple_columns(PODCAST_BY_GENDER_DF, id.var = c("response_id","q11_shared"), default_value = 0, group_column = c("q11_shared","value"))
PODCAST_BY_GENDER_DF_LONG_PERC$new_perc<-PODCAST_BY_GENDER_DF_LONG_PERC$new_perc*100
PODCAST_BY_GENDER_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(PODCAST_BY_GENDER_DF_LONG_PERC, aes(x = factor(PODCAST_BY_GENDER_DF_LONG_PERC$q11_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "podcasts-gender.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Podcasts by Age Caterogries

```{r}
require(vtable)
PODCAST_BY_AGE_CAT<-st(SOCIAL_MEDIA_DF_REDUCED_REPLACED,vars = c("q310_shared_1","q310_shared_2","q310_shared_3","q310_shared_4","q310_shared_5","q310_shared_6","q310_shared_7","q310_shared_8","q310_shared_9"),group="age_categories",out="csv",file="PODCAST_BY_AGE_CATT.csv")
PODCAST_BY_AGE_CAT
```

Podcasts media by Age Caterogries

```{r}
require(dplyr)
PODCAST_BY_AGE_CAT_DF<-dplyr::select(PODCASTS_DF_REDUCED_REPLACED,response_id,age_categories,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)

PODCAST_BY_AGE_CAT_DF_LONG_PERC <- process_data_pipeline_multiple_columns(PODCAST_BY_AGE_CAT_DF, id.var = c("response_id","age_categories"), default_value = 0, group_column = c("age_categories","value"))
PODCAST_BY_AGE_CAT_DF_LONG_PERC$new_perc<-PODCAST_BY_AGE_CAT_DF_LONG_PERC$new_perc*100
PODCAST_BY_AGE_CAT_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(PODCAST_BY_AGE_CAT_DF_LONG_PERC, aes(x = factor(PODCAST_BY_AGE_CAT_DF_LONG_PERC$age_categories), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "podcasts-age-categories.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Podcasts by Awareness of Acrisure

```{r}
require(vtable)
PODCAST_BY_ACRISURE_AWARE<-st(BTQ2,vars = c("q310_shared_1","q310_shared_2","q310_shared_3","q310_shared_4","q310_shared_5","q310_shared_6","q310_shared_7","q310_shared_8","q310_shared_9"),group="q75_shared_1",out="csv",file="PODCAST_BY_ACRISURE_AWARE.csv")
PODCAST_BY_ACRISURE_AWARE
```

Social media by Awareness of Acrisure

```{r}
require(dplyr)
PODCAST_BY_ACRISURE_AWARE_DF<-dplyr::select(PODCASTS_DF_REDUCED_REPLACED,response_id,q75_shared_1,q310_shared_1,q310_shared_2,q310_shared_3,q310_shared_4,q310_shared_5,q310_shared_6,q310_shared_7,q310_shared_8,q310_shared_9)

PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC <- process_data_pipeline_multiple_columns(PODCAST_BY_ACRISURE_AWARE_DF, id.var = c("response_id","q75_shared_1"), default_value = 0, group_column = c("q75_shared_1","value"))
PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC$new_perc<-PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC$new_perc*100
PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC, aes(x = factor(PODCAST_BY_ACRISURE_AWARE_DF_LONG_PERC$q75_shared_1), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "podcasts-awareness-acrisure.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

### Knowledge of Acrisure

Q303_CL:In the previous questions you indicated that you were aware of Acrisure. To the best of your knowledge, which of the following products does Acrisure offer? (Select all that apply)

Please note that your response to this question will not affect your ability to complete the rest of the survey.

-   Factor variable

```{r}
BTQ2_CL$q303_cl_1<-as.factor(BTQ2_CL$q303_cl_1)
BTQ2_CL$q303_cl_2<-as.factor(BTQ2_CL$q303_cl_2)
BTQ2_CL$q303_cl_3<-as.factor(BTQ2_CL$q303_cl_3)
BTQ2_CL$q303_cl_4<-as.factor(BTQ2_CL$q303_cl_4)
BTQ2_CL$q303_cl_5<-as.factor(BTQ2_CL$q303_cl_5)
BTQ2_CL$q303_cl_6<-as.factor(BTQ2_CL$q303_cl_6)
BTQ2_CL$q303_cl_7<-as.factor(BTQ2_CL$q303_cl_7)
BTQ2_CL$q303_cl_8<-as.factor(BTQ2_CL$q303_cl_8)
BTQ2_CL$q303_cl_9<-as.factor(BTQ2_CL$q303_cl_9)
BTQ2_CL$q303_cl_10<-as.factor(BTQ2_CL$q303_cl_10)
BTQ2_CL$q303_cl_11<-as.factor(BTQ2_CL$q303_cl_11)
```

Create table to depict

```{r}
KNOWLEDGDE_OF_ACRISURE<-st(BTQ2_CL,vars=c("q303_cl_1","q303_cl_2","q303_cl_3","q303_cl_4","q303_cl_5","q303_cl_6","q303_cl_7","q303_cl_8","q303_cl_9","q303_cl_10","q303_cl_11"),out="csv",file="KNOWLEDGDE_OF_ACRISURE.csv")
print(KNOWLEDGDE_OF_ACRISURE)
```

Graph the -

```{r}
#| label: fig-Knowledge-of-Acrisure
#| fig-cap: Knowledge of Acrisure
#| warning: false
KNOWLEDGDE_OF_ACRISURE_DF<-dplyr::select(BTQ2_CL,response_id,q303_cl_1,q303_cl_2,q303_cl_3,q303_cl_4,q303_cl_5,q303_cl_6,q303_cl_7,q303_cl_8,q303_cl_9,q303_cl_10,q303_cl_11)
KNOWLEDGDE_OF_ACRISURE_DF_PERC <- process_data_pipeline_multiple_columns(KNOWLEDGDE_OF_ACRISURE_DF, id.var = c("response_id"), default_value = 0, group_column = c("value"))
bar_plot_percent_ordered(KNOWLEDGDE_OF_ACRISURE_DF_PERC, "value", "new_perc", "value", "KNOWLEDGDE_OF_ACRISURE_DF_PERC.png", main_title = "", x_axis_label = " ", y_axis_label = "Pct. Selected",y_limits = 0.5)
```

```{r}
BTQ2_CL<-subset(BTQ2,RESPONDENT_TYPE=="CL")
colnames(BTQ2_CL)
breaks <- seq(0, 500, by = 50)

# Define the labels for the bins
labels <- c('0-50', '51-100', '101-150', '151-200', '201-250', '251-300', '301-350', '351-400','401-450','451-500')

# Convert the numeric variable to a categorical variable
BTQ2_CL$company_size <- cut(BTQ2_CL$q25_cl, breaks = breaks, labels = labels, include.lowest = TRUE)

# Print the result_si
BTQ2_CL$company_size
```

Knowledge of Acrisure by company size

```{r}
KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE<-st(BTQ2_CL,vars=c("q303_cl_1","q303_cl_2","q303_cl_3","q303_cl_4","q303_cl_5","q303_cl_6","q303_cl_7","q303_cl_8","q303_cl_9"),groups="company_size",out="csv",file="KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE.csv")
print(KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE)

```

Knowledge of Acrisure by staff size graph

```{r}
require(dplyr)
KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE<-dplyr::select(BTQ2_CL,response_id,company_size,q303_cl_1,q303_cl_2,q303_cl_3,q303_cl_4,q303_cl_5,q303_cl_6,q303_cl_7,q303_cl_8,q303_cl_9,q303_cl_10,q303_cl_11)

KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC <- process_data_pipeline_multiple_columns(KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE, id.var = c("response_id","company_size"), default_value = 0, group_column = c("company_size","value"))
KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC$new_perc<-KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC$new_perc*100
KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC, aes(x = factor(KNOWLEDGDE_OF_ACRISURE_COMPANY_SIZE_LONG_PERC$company_size), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "KNOWLEDGDE-OF-ACRISURE-COMPANY-SIZE.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Knowledge of Acrisure by industry

```{r}

KNOWLEDGDE_OF_ACRISURE_INDUSTRY<-st(BTQ2_CL,vars=c("q303_cl_1","q303_cl_2","q303_cl_3","q303_cl_4","q303_cl_5","q303_cl_6","q303_cl_7","q303_cl_8","q303_cl_9","q303_cl_10","q303_cl_11"),groups="q21_shared",out="csv",file="KNOWLEDGDE_OF_ACRISURE_INDUSTRY.csv")
print(KNOWLEDGDE_OF_ACRISURE_INDUSTRY)
```

Knowledge of Acrisure by industry graph

```{r}
require(dplyr)
KNOWLEDGDE_OF_ACRISURE_REVENUE<-dplyr::select(BTQ2_CL,response_id,q21_shared,q303_cl_1,q303_cl_2,q303_cl_3,q303_cl_4,q303_cl_5,q303_cl_6,q303_cl_7,q303_cl_8,q303_cl_9,q303_cl_10,q303_cl_11)

KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC <- process_data_pipeline_multiple_columns(KNOWLEDGDE_OF_ACRISURE_REVENUE, id.var = c("response_id","q21_shared"), default_value = 0, group_column = c("q21_shared","value"))
KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$new_perc<-KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$new_perc*100
KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC, aes(x = factor(KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$q21_shared), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "KNOWLEDGDE-OF-ACRISURE-INDUSTRY.png", 
       plot = plot, 
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

Knowledge of Acrisure by revenue

```{r}

KNOWLEDGDE_OF_ACRISURE_REVENUE<-st(BTQ2_CL,vars=c("q303_cl_1","q303_cl_2","q303_cl_3","q303_cl_4","q303_cl_5","q303_cl_6","q303_cl_7","q303_cl_8","q303_cl_9","q303_cl_10","q303_cl_11"),groups="q21_cl",out="csv",file="KNOWLEDGDE_OF_ACRISURE_REVENUE.csv")
print(KNOWLEDGDE_OF_ACRISURE_REVENUE)
```

Knowledge of Acrisure by industry graph

```{r}
require(dplyr)
KNOWLEDGDE_OF_ACRISURE_REVENUE<-dplyr::select(BTQ2_CL,response_id,q21_cl,q303_cl_1,q303_cl_2,q303_cl_3,q303_cl_4,q303_cl_5,q303_cl_6,q303_cl_7,q303_cl_8,q303_cl_9,q303_cl_10,q303_cl_11)

KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC <- process_data_pipeline_multiple_columns(KNOWLEDGDE_OF_ACRISURE_REVENUE, id.var = c("response_id","q21_cl"), default_value = 0, group_column = c("q21_cl","value"))
KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$new_perc<-KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$new_perc*100
KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC


# Custom color palette
custom_palette <- c("#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C",
                    "#002A4E", "#36749D", "#DDE9F0", "#85714D", "#000000", "#004F51", "#95174C")


# Arguments for axis limits
x_lim <- NULL  # Define x-axis limits, e.g., c(0, 10) or NULL for default
y_lim <- c(0, 60)  # Define y-axis limits, e.g., c(0, 80)

# Create the bar plot with specified parameters
plot <- ggplot(KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC, aes(x = factor(KNOWLEDGDE_OF_ACRISURE_REVENUE_LONG_PERC$q21_cl), y = new_perc, fill = value)) +
  geom_bar(position = position_dodge(width = 0.9), stat = "identity", width = 1) +  # Set bar width
  scale_fill_manual(values = custom_palette) +
  
  # Add text labels above each bar with specified decimals, ignoring zeros for text labels
  geom_text(aes(label = ifelse(new_perc > 0, formatC(new_perc, format = 'f', digits = 0), '')),
            position = position_dodge(width = 0.9),  # Adjust to match bar width
            vjust = 1,  # Adjust to place text above the bars
            hjust = 0.5,   # Center the text horizontally
            color = "white", # Set text color to white
            size = 3) +    # Adjust text size
  
  # Add axis labels and title
  labs(title = "", 
       x = "", 
       y = "Pct. Selected (%)") +
  
  # Apply custom theme settings
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(),
    text = element_text(size = 8, family = 'sans'),
    legend.position = c(1,1), # Position legend inside the plot area
    legend.justification = c("right", "top"), # Anchor to the top right
    legend.box.margin = margin(10, 10, 10, 10), # Add margin around the legend
    legend.background = element_rect(fill = "transparent", color = NA), # Transparent legend background
    axis.text.x = element_text(angle = 0, vjust = 1, hjust = 0.5) # x-axis labels settings
  ) +
  labs(fill = NULL) # Remove legend title




# Add x and y limits if specified
if (!is.null(x_lim)) {
  plot <- plot + xlim(x_lim)
}

if (!is.null(y_lim)) {
  plot <- plot + ylim(y_lim)
}


# Display the plot
print(plot)


# Save the plot as a high-resolution image
ggsave(filename = "KNOWLEDGDE-OF-ACRISURE-REVENUE.png", 
       plot = plot,
       dpi = 1800,        # Set the resolution to 1800 DPI
       width = 12,       # Set the width to 12 inches
       height = 4.5)     # Set the height to 4.5 inches

```

#How did you first learn about Acrisure? Please describe how you learned about Acrisure with a short phrase or sentence.

If you can't remember please proceed to the next question.
```{r}
generate_wordcloud(BTQ2_CL, "q311_shared", "find-out-acrisure.png")
BTQ2_CL_REVISED<-subset(BTQ2_CL,BTQ2_CL$q311_shared!='NA')
plot_top_phrases(BTQ2_CL_REVISED, "q311_shared", "CL-plot-function-of-acrisure.png")
```

Q303_PL: In the previous questions you indicated that you were aware of Acrisure. To the best of your knowledge, what does Acrisure do? Please describe what Acrisure does or what you know about Acrisure in a short sentence.
If you do not know please type 'Don't know' into the box below.  Do not look up the answer. Your response to this question will not affect your ability to participate in the rest of the survey.
```{r}
generate_wordcloud(BTQ2_PL, "q303_pl", "function-of-acrisure.png")
BTQ2_PL_REVISED<-subset(BTQ2_PL,BTQ2_PL$q303_pl!='NA')
plot_top_phrases(BTQ2_PL_REVISED, "q303_pl", "PL-plot-function-of-acrisure.png")
```


Q311_SHARED. - PL< How did you first learn about Acrisure? Please describe how you learned about Acrisure with a short phrase or sentence.

If you can't remember please proceed to the next question. 
```{r}
generate_wordcloud(BTQ2_PL, "q311_shared", "find-out-acrisure.png")
BTQ2_PL_REVISED<-subset(BTQ2_PL,BTQ2_PL$q311_shared!='NA')
plot_top_phrases(BTQ2_PL_REVISED, "q311_shared", "Learn-PL-plot-function-of-acrisure.png")
```


Q311_SHARED. - PL< How did you first learn about Acrisure? Please describe how you learned about Acrisure with a short phrase or sentence.

If you can't remember please proceed to the next question. 
```{r}
generate_wordcloud(BTQ2_CL, "q311_shared", "CL-find-out-acrisure.png")
BTQ2_CL_REVISED<-subset(BTQ2_CL,BTQ2_CL$q311_shared!='NA')
plot_top_phrases(BTQ2_CL_REVISED, "q311_shared", "Learn-CL-plot-function-of-acrisure.png")
```